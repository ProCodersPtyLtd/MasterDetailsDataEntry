<#//@ include file="$(PlatzObjectBuilderTemplateDirectory)PlatzDataService.Tools.ttinclude" #>
<#@ assembly name="$(SolutionDir)..\..\Platz.ObjectBuilder.Templates\bin\Debug\Platz.ObjectBuilder.Templates.dll" #>
<#@ template language="C#" hostspecific="True" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#@ import namespace="Platz.ObjectBuilder" #>
<#@ import namespace="Platz.SqlForms" #>
<#@ import namespace="Platz.ObjectBuilder.Expressions" #>
<#@ import namespace="Platz.ObjectBuilder.Helpers" #>
<# // ================================================================ Set JsonStorePath here, relative to solution folder ================================== #>
<#      var JsonStorePath = @"MyApp\SqlForms\QueryStore";  #>
<# // ======================================================================================================================================================= #>
<# 
        StoreSchema Schema = null;
        List<StoreQuery> Queries = new List<StoreQuery>();
        JsonStoreSchemaParser Parser = new JsonStoreSchemaParser();
        var _expression = new SqlExpressionEngine(new SqlJsonObjectResolver());

        ReadFiles(); 
#>
// *******************************************************************************************************
// This code is auto generated by Platz.ObjectBuilder template, any changes made to this code will be lost
// *******************************************************************************************************
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Platz.ObjectBuilder;
using Platz.SqlForms;
<#
    var contextName = Schema.DbContextName;
    var contextNamelist = contextName.Split('.').ToList();
    var ctxName = contextNamelist.Last();
    contextNamelist.Remove(contextNamelist.Last());
    var namespaceName = string.Join(".", contextNamelist.ToArray());
#>
using <#=namespaceName#>;

<#
    if (Queries != null && Queries.Count > 0)
    {
#>
namespace <#=Queries.First().Namespace#>
{
    #region Interface 

    public partial interface I<#=Queries.First().DataService#>
    {
<#
        foreach (var query in Queries)
        {
#>
        List<<#=query.ReturnTypeName#>> <#=query.Name#>(QueryOptions options, params object[] parameters);
<#
        }
#>
    }

    #endregion

    #region Data Service 

    public partial class <#=Queries.First().DataService#> : DataServiceBase<<#=ctxName#>>, I<#=Queries.First().DataService#>
    {
<# 
        foreach (var query in Queries)
        {
            var from = Parser.ReadFrom(query, Schema);
            var joins = Parser.ReadJoins(query, Schema);
            var where = Parser.QueryExprToString(query.Query.Where.Expression, JsonStoreSchemaParser.CSharpOperatorsMap);
            var parameters = Parser.ReadParameters(query);

            var sq = SortSubQueries(query);

#>
        public List<<#=query.ReturnTypeName#>> <#=query.Name#>(QueryOptions options, params object[] parameters)
        {
            using (var db = GetDbContext())
            {
                var query = <#=query.Name#>Query(db, options, parameters);
                query = Prepare(query, options, parameters);
                var result = GetResult(query, options, parameters);
                return result;
            }
        }

        public IQueryable<<#=query.ReturnTypeName#>> <#=query.Name#>Query(<#=ctxName#> db, QueryOptions options, params object[] parameters)
        {
<#
            if (query.Query.Parameters != null && query.Query.Parameters.Any())
            {
                for (int i = 0; i < parameters.Count; i++)
                {
                    var p = parameters[i];
#>
            var <#=p.Name#> = (<#=p.Type#>)parameters[<#=i#>];
<#
                }
#>

<#
            }

            foreach (var subQuery in sq)
            {
                AppendSingleQuery(Parser, Schema, subQuery.Value, subQuery.Key, "", query.Query.SubQueries);
            }

            AppendSingleQuery(Parser, Schema, query.Query, "query", query.ReturnTypeName, query.Query.SubQueries);
#>

            return query;
        }

<#
        }
#>
    }

    #endregion

    #region Entities

<#
        foreach (var query in Queries)
        {
            var subQueries = query.Query.SubQueries;
#>
    public partial class <#=query.ReturnTypeName#>
    {
<#
            foreach (var field in query.Query.Fields.Values.Where(f => f.IsOutput))
            {
                var table = query.Query.Tables[field.Field.ObjectAlias];

                if (table.IsSubQuery)
                {
                    string originalPropertyName = field.FieldAlias;

                    while (table.IsSubQuery)
                    {
                        var sq = subQueries[table.TableName];
                        var sqf = sq.Fields[originalPropertyName];
                        originalPropertyName = sqf.Field.FieldName;
                        var sqt = sq.Tables[sqf.Field.ObjectAlias];
                        table = sqt;
                    }

                    var definition = Schema.Definitions[table.TableName];
                    var property = definition.Properties[originalPropertyName];
#>
        public <#=property.Type#> <#=field.FieldAlias#> { get; set; }
<#
                }
                else
                {
                    var definition = Schema.Definitions[table.TableName];
                    var property = definition.Properties[field.Field.FieldName];
#>
        public <#=property.Type#> <#=field.FieldAlias#> { get; set; }
<#
                }
            }
#>
    }

<#
        }
#>
    #endregion
}
<#
    }
        void ReadFiles()
        {
            var parser = new JsonStoreSchemaParser();
            var path = Path.Combine(GetSolutionDirectory(), JsonStorePath);
            var files = Directory.GetFiles(path);

            foreach (var file in files)
            {
                var json = File.ReadAllText(file);

                if (Path.GetFileName(file).ToLower() == "schema.json")
                {
                    Schema = parser.ReadSchema(json);
                }
                else
                {
                    var q = parser.ReadQuery(json);
                    Queries.Add(q);
                }
            }
        }

        List<KeyValuePair<string, StoreQueryDefinition>> SortSubQueries(StoreQuery query)
        {
            if (query.Query.SubQueries == null)
            {
                return new List<KeyValuePair<string, StoreQueryDefinition>>();
            }

            var result = query.Query.SubQueries.ToList();
            result.Sort(delegate (KeyValuePair<string, StoreQueryDefinition> a, KeyValuePair<string, StoreQueryDefinition> b)
            {
                if (a.Value.Tables.Any(t => t.Value.TableName == b.Key))
                {
                    return 1;
                }

                if (b.Value.Tables.Any(t => t.Value.TableName == a.Key))
                {
                    return -1;
                }

                return 0;
            });

            return result;
        }

        void AppendSingleGroupByQuery(JsonStoreSchemaParser parser, StoreSchema schema, StoreQueryDefinition query, string queryName,
            string returnTypeName, Dictionary<string, StoreQueryDefinition> subQueries)
        {
            var from = parser.ReadFrom(query, schema);
            var joins = parser.ReadJoins(query, schema);
            var where = parser.QueryExprToString(query.Where.Expression, JsonStoreSchemaParser.CSharpOperatorsMap);

            string dbPrefix;
            dbPrefix = query.Tables[from.LeftObjectAlias].IsSubQuery ? "" : "db.";
#>            
            var <#=queryName#> =
                from <#=from.LeftObjectAlias#> in <#=dbPrefix#><#=from.LeftObject#>
<#
            foreach (var j in joins)
            {
                dbPrefix = query.Tables[j.RightObjectAlias].IsSubQuery ? "" : "db.";
#>
                join <#=j.RightObjectAlias#> in <#=dbPrefix#><#=j.RightObject#> on <#=j.LeftObjectAlias#>.<#=j.LeftField#> equals <#=j.RightObjectAlias#>.<#=j.RightField#>
<#
            }

            if (!string.IsNullOrWhiteSpace(where))
            {
#>
                where <#=where#>
<#
            }

            var gbAliases = query.Fields.Values.Where(f => f.GroupByFunction == "Group By").Select(f => f.Field.ObjectAlias).Distinct();
            var gbFields = query.Fields.Values.Where(f => f.GroupByFunction == "Group By").Select(f => $"{f.Field.ObjectAlias}.{f.FieldAlias}").Distinct();

            string groupVar = "group1";
#>
                group new { <#=string.Join(", ", gbAliases)#> } by new { <#=string.Join(", ", gbFields)#> } into <#=groupVar#>
<#          
            var havingFields = query.Fields.Values.Where(f => !string.IsNullOrWhiteSpace(f.GroupByFilter));

            if (havingFields.Any())
            {
                var having = "";

                foreach (var field in havingFields)
                {
                    if (!string.IsNullOrWhiteSpace(having))
                    {
                        having += " && ";
                    }

                    var grpbExpr = GetGroupBySelectField(field, groupVar, gbAliases);
                    
                    // convert filter fo EF LINQ expression
                    var filterExpr = GetFilterQueryExpression(_expression, field, field.GroupByFilter);
                    var cond = parser.QueryExprToString(filterExpr, JsonStoreSchemaParser.CSharpOperatorsMap);
                    cond = cond.Replace($"{field.Field.ObjectAlias}.{field.FieldAlias} ", "");
                    having += $"{grpbExpr} {cond}";
                }
#>
                where <#=having#>
<#
            }

#>
                select new <#=returnTypeName#>
                { 
<#          
            foreach (var field in query.Fields.Values.Where(f => f.IsOutput))
            {
                var exprField = GetGroupBySelectField(field, groupVar, gbAliases);

#>                    <#=field.FieldAlias#> = <#=exprField#>, 
<#
            }
#>
                };
<#
        }

        void AppendSingleQuery(JsonStoreSchemaParser parser, StoreSchema schema, StoreQueryDefinition query, string queryName,
            string returnTypeName, Dictionary<string, StoreQueryDefinition> subQueries)
        {
            if (query.Fields.Values.Any(f => f.GroupByFunction == "Group By"))
            {
                AppendSingleGroupByQuery(parser, schema, query, queryName,returnTypeName, subQueries);
                return;
            }

            var from = parser.ReadFrom(query, schema);
            var joins = parser.ReadJoins(query, schema);
            var where = parser.QueryExprToString(query.Where.Expression, JsonStoreSchemaParser.CSharpOperatorsMap);

            string dbPrefix;
            dbPrefix = query.Tables[from.LeftObjectAlias].IsSubQuery ? "" : "db.";
#>            
                var <#=queryName#> =
                    from <#=from.LeftObjectAlias#> in <#=dbPrefix#><#=from.LeftObject#>
<#
            foreach (var j in joins)
            {
                dbPrefix = query.Tables[j.RightObjectAlias].IsSubQuery ? "" : "db.";
#>
                    join <#=j.RightObjectAlias#> in <#=dbPrefix#><#=j.RightObject#> on <#=j.LeftObjectAlias#>.<#=j.LeftField#> equals <#=j.RightObjectAlias#>.<#=j.RightField#>
<#
            }

            if (!string.IsNullOrWhiteSpace(where))
            {
#>
                    where <#=where#>
<#
            }
#>
                    select new <#=returnTypeName#>
                    { 
<#          
            foreach (var field in query.Fields.Values.Where(f => f.IsOutput))
            {
                var table = query.Tables[field.Field.ObjectAlias];

                if (table.IsSubQuery)
                {
                    var definition = subQueries[table.TableName];
                    var property = definition.Fields[field.Field.FieldName];

#>                        <#=field.FieldAlias#> = <#=field.Field.ObjectAlias#>.<#=field.Field.FieldName#>, 
<#
                }
                else
                {
                    var definition = schema.Definitions[table.TableName];
                    var property = definition.Properties[field.Field.FieldName];

#>                        <#=field.FieldAlias#> = <#=field.Field.ObjectAlias#>.<#=field.Field.FieldName#>, 
<#
                }
            }
#>
                    };
<#
        }

        QueryExpression GetFilterQueryExpression(ISqlExpressionEngine expressions, StoreQueryField field, string filter)
        {
            var filterClause = $"{field.Field.ObjectAlias}.{field.FieldAlias} {filter}";
            var expr = expressions.BuildExpressionTree(filterClause);
            var result = QueryExpressionHelper.ReadFromSqlExpr(expr);
            return result;
        }

        string GetGroupBySelectField(StoreQueryField field, string groupVar, IEnumerable<string> gbAliases)
        {
            string function;

            if (string.IsNullOrWhiteSpace(field.GroupByFunction))
            {
                function = $"{field.Field.ObjectAlias}.{field.Field.FieldName}";
            }
            else if (field.GroupByFunction == "Group By")
            {
                function = $"{groupVar}.Key.{field.Field.FieldName}";
            }
            else if (field.GroupByFunction == "Count")
            {
                function = $"{groupVar}.Count()";
            }
            else
            {
                function = $"{groupVar}.{field.GroupByFunction}(x => x.{field.Field.ObjectAlias}.{field.Field.FieldName})";
            }

            return function;
        }

        // t4 specific methods

        string GetSolutionDirectory()
        {
            var serviceProvider = this.Host as IServiceProvider;
            var dte = serviceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
            return System.IO.Path.GetDirectoryName(dte.Solution.FullName);
        }
#>